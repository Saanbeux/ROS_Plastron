Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    NODE
    NODELET

Grammar

Rule 0     S' -> def
Rule 1     def -> NAME EQUALS STRING_LITERAL
Rule 2     def -> NAME EQUALS INT
Rule 3     def -> NAME EQUALS CHAR_LITERAL
Rule 4     def -> NAME EQUALS NAME
Rule 5     def -> NAME EQUALS func
Rule 6     def -> NAME EQUALS NAME DOT mod
Rule 7     func -> prim_f paren
Rule 8     var_mod -> NAME DOT mod
Rule 9     mod -> prim_m paren
Rule 10    prim_f -> CREATE_NODE
Rule 11    prim_f -> CREATE_MSGS
Rule 12    prim_f -> LOAD
Rule 13    prim_f -> GENERATE_LAUNCH
Rule 14    prim_f -> CREATE_NODELET
Rule 15    exp -> def
Rule 16    exp -> func
Rule 17    exp -> var_mod
Rule 18    prim_m -> PUBLISH
Rule 19    prim_m -> SUBSCRIBE
Rule 20    prim_m -> UNSUBSCRIBE
Rule 21    prim_m -> SERVICE
Rule 22    prim_m -> CLIENT
Rule 23    paren -> paren1
Rule 24    paren -> paren2
Rule 25    paren1 -> LEFT_P NAME COMMA STRING_LITERAL RIGHT_P
Rule 26    paren1 -> LEFT_P STRING_LITERAL COMMA communication RIGHT_P
Rule 27    paren2 -> LEFT_P STRING_LITERAL RIGHT_P
Rule 28    paren2 -> LEFT_P EMPTY RIGHT_P
Rule 29    communication -> SUBSCRIBER
Rule 30    communication -> SERVER

Terminals, with rules where they appear

CHAR_LITERAL         : 3
CLIENT               : 22
COMMA                : 25 26
CREATE_MSGS          : 11
CREATE_NODE          : 10
CREATE_NODELET       : 14
DOT                  : 6 8
EMPTY                : 28
EQUALS               : 1 2 3 4 5 6
GENERATE_LAUNCH      : 13
INT                  : 2
LEFT_P               : 25 26 27 28
LOAD                 : 12
NAME                 : 1 2 3 4 4 5 6 6 8 25
NODE                 : 
NODELET              : 
PUBLISH              : 18
RIGHT_P              : 25 26 27 28
SERVER               : 30
SERVICE              : 21
STRING_LITERAL       : 1 25 26 27
SUBSCRIBE            : 19
SUBSCRIBER           : 29
UNSUBSCRIBE          : 20
error                : 

Nonterminals, with rules where they appear

communication        : 26
def                  : 15 0
exp                  : 
func                 : 5 16
mod                  : 6 8
paren                : 7 9
paren1               : 23
paren2               : 24
prim_f               : 7
prim_m               : 9
var_mod              : 17

Parsing method: LALR

state 0

    (0) S' -> . def
    (1) def -> . NAME EQUALS STRING_LITERAL
    (2) def -> . NAME EQUALS INT
    (3) def -> . NAME EQUALS CHAR_LITERAL
    (4) def -> . NAME EQUALS NAME
    (5) def -> . NAME EQUALS func
    (6) def -> . NAME EQUALS NAME DOT mod

    NAME            shift and go to state 2

    def                            shift and go to state 1

state 1

    (0) S' -> def .



state 2

    (1) def -> NAME . EQUALS STRING_LITERAL
    (2) def -> NAME . EQUALS INT
    (3) def -> NAME . EQUALS CHAR_LITERAL
    (4) def -> NAME . EQUALS NAME
    (5) def -> NAME . EQUALS func
    (6) def -> NAME . EQUALS NAME DOT mod

    EQUALS          shift and go to state 3


state 3

    (1) def -> NAME EQUALS . STRING_LITERAL
    (2) def -> NAME EQUALS . INT
    (3) def -> NAME EQUALS . CHAR_LITERAL
    (4) def -> NAME EQUALS . NAME
    (5) def -> NAME EQUALS . func
    (6) def -> NAME EQUALS . NAME DOT mod
    (7) func -> . prim_f paren
    (10) prim_f -> . CREATE_NODE
    (11) prim_f -> . CREATE_MSGS
    (12) prim_f -> . LOAD
    (13) prim_f -> . GENERATE_LAUNCH
    (14) prim_f -> . CREATE_NODELET

    STRING_LITERAL  shift and go to state 4
    INT             shift and go to state 5
    CHAR_LITERAL    shift and go to state 8
    NAME            shift and go to state 11
    CREATE_NODE     shift and go to state 14
    CREATE_MSGS     shift and go to state 9
    LOAD            shift and go to state 12
    GENERATE_LAUNCH shift and go to state 13
    CREATE_NODELET  shift and go to state 7

    prim_f                         shift and go to state 6
    func                           shift and go to state 10

state 4

    (1) def -> NAME EQUALS STRING_LITERAL .

    $end            reduce using rule 1 (def -> NAME EQUALS STRING_LITERAL .)


state 5

    (2) def -> NAME EQUALS INT .

    $end            reduce using rule 2 (def -> NAME EQUALS INT .)


state 6

    (7) func -> prim_f . paren
    (23) paren -> . paren1
    (24) paren -> . paren2
    (25) paren1 -> . LEFT_P NAME COMMA STRING_LITERAL RIGHT_P
    (26) paren1 -> . LEFT_P STRING_LITERAL COMMA communication RIGHT_P
    (27) paren2 -> . LEFT_P STRING_LITERAL RIGHT_P
    (28) paren2 -> . LEFT_P EMPTY RIGHT_P

    LEFT_P          shift and go to state 18

    paren2                         shift and go to state 15
    paren                          shift and go to state 16
    paren1                         shift and go to state 17

state 7

    (14) prim_f -> CREATE_NODELET .

    LEFT_P          reduce using rule 14 (prim_f -> CREATE_NODELET .)


state 8

    (3) def -> NAME EQUALS CHAR_LITERAL .

    $end            reduce using rule 3 (def -> NAME EQUALS CHAR_LITERAL .)


state 9

    (11) prim_f -> CREATE_MSGS .

    LEFT_P          reduce using rule 11 (prim_f -> CREATE_MSGS .)


state 10

    (5) def -> NAME EQUALS func .

    $end            reduce using rule 5 (def -> NAME EQUALS func .)


state 11

    (4) def -> NAME EQUALS NAME .
    (6) def -> NAME EQUALS NAME . DOT mod

    $end            reduce using rule 4 (def -> NAME EQUALS NAME .)
    DOT             shift and go to state 19


state 12

    (12) prim_f -> LOAD .

    LEFT_P          reduce using rule 12 (prim_f -> LOAD .)


state 13

    (13) prim_f -> GENERATE_LAUNCH .

    LEFT_P          reduce using rule 13 (prim_f -> GENERATE_LAUNCH .)


state 14

    (10) prim_f -> CREATE_NODE .

    LEFT_P          reduce using rule 10 (prim_f -> CREATE_NODE .)


state 15

    (24) paren -> paren2 .

    $end            reduce using rule 24 (paren -> paren2 .)


state 16

    (7) func -> prim_f paren .

    $end            reduce using rule 7 (func -> prim_f paren .)


state 17

    (23) paren -> paren1 .

    $end            reduce using rule 23 (paren -> paren1 .)


state 18

    (25) paren1 -> LEFT_P . NAME COMMA STRING_LITERAL RIGHT_P
    (26) paren1 -> LEFT_P . STRING_LITERAL COMMA communication RIGHT_P
    (27) paren2 -> LEFT_P . STRING_LITERAL RIGHT_P
    (28) paren2 -> LEFT_P . EMPTY RIGHT_P

    NAME            shift and go to state 22
    STRING_LITERAL  shift and go to state 20
    EMPTY           shift and go to state 21


state 19

    (6) def -> NAME EQUALS NAME DOT . mod
    (9) mod -> . prim_m paren
    (18) prim_m -> . PUBLISH
    (19) prim_m -> . SUBSCRIBE
    (20) prim_m -> . UNSUBSCRIBE
    (21) prim_m -> . SERVICE
    (22) prim_m -> . CLIENT

    PUBLISH         shift and go to state 23
    SUBSCRIBE       shift and go to state 25
    UNSUBSCRIBE     shift and go to state 28
    SERVICE         shift and go to state 24
    CLIENT          shift and go to state 29

    prim_m                         shift and go to state 26
    mod                            shift and go to state 27

state 20

    (26) paren1 -> LEFT_P STRING_LITERAL . COMMA communication RIGHT_P
    (27) paren2 -> LEFT_P STRING_LITERAL . RIGHT_P

    COMMA           shift and go to state 31
    RIGHT_P         shift and go to state 30


state 21

    (28) paren2 -> LEFT_P EMPTY . RIGHT_P

    RIGHT_P         shift and go to state 32


state 22

    (25) paren1 -> LEFT_P NAME . COMMA STRING_LITERAL RIGHT_P

    COMMA           shift and go to state 33


state 23

    (18) prim_m -> PUBLISH .

    LEFT_P          reduce using rule 18 (prim_m -> PUBLISH .)


state 24

    (21) prim_m -> SERVICE .

    LEFT_P          reduce using rule 21 (prim_m -> SERVICE .)


state 25

    (19) prim_m -> SUBSCRIBE .

    LEFT_P          reduce using rule 19 (prim_m -> SUBSCRIBE .)


state 26

    (9) mod -> prim_m . paren
    (23) paren -> . paren1
    (24) paren -> . paren2
    (25) paren1 -> . LEFT_P NAME COMMA STRING_LITERAL RIGHT_P
    (26) paren1 -> . LEFT_P STRING_LITERAL COMMA communication RIGHT_P
    (27) paren2 -> . LEFT_P STRING_LITERAL RIGHT_P
    (28) paren2 -> . LEFT_P EMPTY RIGHT_P

    LEFT_P          shift and go to state 18

    paren2                         shift and go to state 15
    paren1                         shift and go to state 17
    paren                          shift and go to state 34

state 27

    (6) def -> NAME EQUALS NAME DOT mod .

    $end            reduce using rule 6 (def -> NAME EQUALS NAME DOT mod .)


state 28

    (20) prim_m -> UNSUBSCRIBE .

    LEFT_P          reduce using rule 20 (prim_m -> UNSUBSCRIBE .)


state 29

    (22) prim_m -> CLIENT .

    LEFT_P          reduce using rule 22 (prim_m -> CLIENT .)


state 30

    (27) paren2 -> LEFT_P STRING_LITERAL RIGHT_P .

    $end            reduce using rule 27 (paren2 -> LEFT_P STRING_LITERAL RIGHT_P .)


state 31

    (26) paren1 -> LEFT_P STRING_LITERAL COMMA . communication RIGHT_P
    (29) communication -> . SUBSCRIBER
    (30) communication -> . SERVER

    SUBSCRIBER      shift and go to state 37
    SERVER          shift and go to state 35

    communication                  shift and go to state 36

state 32

    (28) paren2 -> LEFT_P EMPTY RIGHT_P .

    $end            reduce using rule 28 (paren2 -> LEFT_P EMPTY RIGHT_P .)


state 33

    (25) paren1 -> LEFT_P NAME COMMA . STRING_LITERAL RIGHT_P

    STRING_LITERAL  shift and go to state 38


state 34

    (9) mod -> prim_m paren .

    $end            reduce using rule 9 (mod -> prim_m paren .)


state 35

    (30) communication -> SERVER .

    RIGHT_P         reduce using rule 30 (communication -> SERVER .)


state 36

    (26) paren1 -> LEFT_P STRING_LITERAL COMMA communication . RIGHT_P

    RIGHT_P         shift and go to state 39


state 37

    (29) communication -> SUBSCRIBER .

    RIGHT_P         reduce using rule 29 (communication -> SUBSCRIBER .)


state 38

    (25) paren1 -> LEFT_P NAME COMMA STRING_LITERAL . RIGHT_P

    RIGHT_P         shift and go to state 40


state 39

    (26) paren1 -> LEFT_P STRING_LITERAL COMMA communication RIGHT_P .

    $end            reduce using rule 26 (paren1 -> LEFT_P STRING_LITERAL COMMA communication RIGHT_P .)


state 40

    (25) paren1 -> LEFT_P NAME COMMA STRING_LITERAL RIGHT_P .

    $end            reduce using rule 25 (paren1 -> LEFT_P NAME COMMA STRING_LITERAL RIGHT_P .)

